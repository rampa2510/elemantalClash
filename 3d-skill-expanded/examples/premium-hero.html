<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Premium 3D Hero</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { scroll-behavior: smooth; }
    body { 
      font-family: system-ui, -apple-system, sans-serif;
      background: #0a0a0a;
      color: white;
      overflow-x: hidden;
    }
    
    /* Canvas - Full viewport fixed */
    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    
    /* Content overlay */
    .content {
      position: relative;
      z-index: 1;
    }
    
    /* Hero section */
    .hero {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 2rem;
    }
    
    .hero h1 {
      font-size: clamp(3rem, 12vw, 10rem);
      font-weight: 100;
      letter-spacing: -0.05em;
      line-height: 0.9;
      opacity: 0;
      transform: translateY(50px);
    }
    
    .hero p {
      font-size: clamp(1rem, 2vw, 1.5rem);
      opacity: 0;
      transform: translateY(30px);
      margin-top: 1.5rem;
      max-width: 600px;
      color: rgba(255,255,255,0.7);
    }
    
    /* Scroll sections */
    .section {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 4rem;
      max-width: 800px;
      margin: 0 auto;
    }
    
    .section h2 {
      font-size: clamp(2rem, 6vw, 4rem);
      font-weight: 200;
      margin-bottom: 1.5rem;
    }
    
    .section p {
      font-size: 1.125rem;
      line-height: 1.7;
      color: rgba(255,255,255,0.7);
    }
    
    /* Loading screen */
    .loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .loader-text {
      font-size: 1rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      margin-bottom: 2rem;
    }
    
    .loader-bar {
      width: 200px;
      height: 2px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      overflow: hidden;
    }
    
    .loader-progress {
      height: 100%;
      width: 0%;
      background: white;
      transition: width 0.3s ease;
    }
    
    /* Scroll indicator */
    .scroll-indicator {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      z-index: 10;
    }
    
    .scroll-indicator span {
      display: block;
      width: 2px;
      height: 40px;
      background: linear-gradient(to bottom, white, transparent);
      animation: scrollPulse 2s ease-in-out infinite;
    }
    
    @keyframes scrollPulse {
      0%, 100% { opacity: 1; transform: scaleY(1); }
      50% { opacity: 0.5; transform: scaleY(0.7); }
    }
    
    /* Reduced motion */
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        transition-duration: 0.01ms !important;
      }
    }
  </style>
</head>
<body>
  <!-- Loading Screen -->
  <div class="loader">
    <div class="loader-text">Loading Experience</div>
    <div class="loader-bar">
      <div class="loader-progress"></div>
    </div>
  </div>

  <!-- WebGL Canvas -->
  <canvas id="canvas"></canvas>
  
  <!-- Content -->
  <div class="content">
    <section class="hero">
      <h1>Premium<br>Experience</h1>
      <p>Immersive 3D storytelling with scroll-driven animations and cinematic visuals</p>
    </section>
    
    <section class="section">
      <h2>Bold Transformations</h2>
      <p>Every scroll reveals a new perspective. The 3D scene responds to your journey, transforming dramatically as you explore the narrative.</p>
    </section>
    
    <section class="section">
      <h2>Cinematic Quality</h2>
      <p>Professional lighting, premium materials, and carefully crafted post-processing create an experience that rivals offline rendering.</p>
    </section>
    
    <section class="section">
      <h2>Flawless Performance</h2>
      <p>60fps animations, optimized rendering, and smooth scroll integration ensure a buttery experience across all devices.</p>
    </section>
  </div>
  
  <!-- Scroll Indicator -->
  <div class="scroll-indicator">
    <span></span>
  </div>

  <!-- Import Maps -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
      "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.5/+esm"
    }
  }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import gsap from 'gsap';
    
    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
      particleCount: 3000,
      cameraPath: [
        { pos: [0, 0, 8], target: [0, 0, 0] },
        { pos: [4, 2, 6], target: [0, 1, 0] },
        { pos: [-3, 3, 5], target: [0, 0.5, 0] },
        { pos: [0, 1, 4], target: [0, 0, 0] }
      ]
    };
    
    // ============================================
    // CORE SETUP
    // ============================================
    const canvas = document.getElementById('canvas');
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    
    // Check WebGL
    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
    if (!gl) {
      document.querySelector('.loader').innerHTML = '<p>WebGL not supported</p>';
      throw new Error('WebGL not supported');
    }
    
    // Renderer with premium settings
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      powerPreference: 'high-performance'
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    
    // Scene
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0a0a, 0.08);
    
    // Camera
    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.set(0, 0, 8);
    
    // ============================================
    // POST-PROCESSING
    // ============================================
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    
    // Bloom
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.6,   // strength
      0.4,   // radius
      0.85   // threshold
    );
    composer.addPass(bloomPass);
    
    // Vignette + Grain
    const postShader = {
      uniforms: {
        tDiffuse: { value: null },
        uTime: { value: 0 },
        uVignetteDarkness: { value: 0.5 },
        uGrainAmount: { value: 0.03 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float uTime;
        uniform float uVignetteDarkness;
        uniform float uGrainAmount;
        varying vec2 vUv;
        
        float random(vec2 co) {
          return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
        }
        
        void main() {
          vec4 color = texture2D(tDiffuse, vUv);
          
          // Vignette
          float dist = length(vUv - 0.5);
          float vignette = smoothstep(0.8, 0.3, dist * (uVignetteDarkness + 0.5));
          color.rgb *= vignette;
          
          // Film grain
          float grain = (random(vUv + uTime) - 0.5) * uGrainAmount;
          color.rgb += grain;
          
          gl_FragColor = color;
        }
      `
    };
    const postPass = new ShaderPass(postShader);
    composer.addPass(postPass);
    
    // ============================================
    // HERO OBJECT
    // ============================================
    const heroGeometry = new THREE.IcosahedronGeometry(1.5, 4);
    const heroMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uProgress: { value: 0 },
        uMouse: { value: new THREE.Vector2(0, 0) },
        uColorA: { value: new THREE.Color('#4a00e0') },
        uColorB: { value: new THREE.Color('#00d4ff') }
      },
      vertexShader: `
        uniform float uTime;
        uniform float uProgress;
        uniform vec2 uMouse;
        
        varying vec2 vUv;
        varying vec3 vNormal;
        varying float vDisplacement;
        
        // Simplex noise function
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        
        float snoise(vec3 v) {
          const vec2 C = vec2(1.0/6.0, 1.0/3.0);
          const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
          vec3 i = floor(v + dot(v, C.yyy));
          vec3 x0 = v - i + dot(i, C.xxx);
          vec3 g = step(x0.yzx, x0.xyz);
          vec3 l = 1.0 - g;
          vec3 i1 = min(g.xyz, l.zxy);
          vec3 i2 = max(g.xyz, l.zxy);
          vec3 x1 = x0 - i1 + C.xxx;
          vec3 x2 = x0 - i2 + C.yyy;
          vec3 x3 = x0 - D.yyy;
          i = mod289(i);
          vec4 p = permute(permute(permute(
            i.z + vec4(0.0, i1.z, i2.z, 1.0))
            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
            + i.x + vec4(0.0, i1.x, i2.x, 1.0));
          float n_ = 0.142857142857;
          vec3 ns = n_ * D.wyz - D.xzx;
          vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
          vec4 x_ = floor(j * ns.z);
          vec4 y_ = floor(j - 7.0 * x_);
          vec4 x = x_ *ns.x + ns.yyyy;
          vec4 y = y_ *ns.x + ns.yyyy;
          vec4 h = 1.0 - abs(x) - abs(y);
          vec4 b0 = vec4(x.xy, y.xy);
          vec4 b1 = vec4(x.zw, y.zw);
          vec4 s0 = floor(b0)*2.0 + 1.0;
          vec4 s1 = floor(b1)*2.0 + 1.0;
          vec4 sh = -step(h, vec4(0.0));
          vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
          vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
          vec3 p0 = vec3(a0.xy, h.x);
          vec3 p1 = vec3(a0.zw, h.y);
          vec3 p2 = vec3(a1.xy, h.z);
          vec3 p3 = vec3(a1.zw, h.w);
          vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
          p0 *= norm.x;
          p1 *= norm.y;
          p2 *= norm.z;
          p3 *= norm.w;
          vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
          m = m * m;
          return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
        }
        
        void main() {
          vUv = uv;
          vNormal = normal;
          
          // Noise-based displacement
          float noise = snoise(position * 2.0 + uTime * 0.5);
          float displacement = noise * 0.2 * (1.0 + uProgress * 0.5);
          
          // Mouse influence
          vec2 mouseInfluence = uMouse * 0.2;
          
          vec3 newPosition = position + normal * displacement;
          newPosition.xy += mouseInfluence * (1.0 - length(position.xy) * 0.2);
          
          vDisplacement = displacement;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
        }
      `,
      fragmentShader: `
        uniform float uTime;
        uniform float uProgress;
        uniform vec3 uColorA;
        uniform vec3 uColorB;
        
        varying vec2 vUv;
        varying vec3 vNormal;
        varying float vDisplacement;
        
        void main() {
          // Gradient based on displacement and normal
          float mixFactor = vDisplacement * 2.0 + 0.5;
          mixFactor += vNormal.y * 0.3;
          mixFactor = clamp(mixFactor, 0.0, 1.0);
          
          vec3 color = mix(uColorA, uColorB, mixFactor);
          
          // Add rim lighting
          float rim = 1.0 - max(0.0, dot(vNormal, vec3(0.0, 0.0, 1.0)));
          rim = pow(rim, 3.0);
          color += rim * 0.5;
          
          // Fresnel glow
          float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
          color += fresnel * uColorB * 0.3;
          
          gl_FragColor = vec4(color, 1.0);
        }
      `,
      wireframe: false
    });
    
    const heroMesh = new THREE.Mesh(heroGeometry, heroMaterial);
    scene.add(heroMesh);
    
    // ============================================
    // PARTICLES
    // ============================================
    const particlesGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(CONFIG.particleCount * 3);
    const randoms = new Float32Array(CONFIG.particleCount);
    
    for (let i = 0; i < CONFIG.particleCount; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = 3 + Math.random() * 5;
      
      positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
      positions[i * 3 + 2] = r * Math.cos(phi);
      
      randoms[i] = Math.random();
    }
    
    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
    
    const particlesMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uProgress: { value: 0 },
        uSize: { value: 30 * renderer.getPixelRatio() }
      },
      vertexShader: `
        uniform float uTime;
        uniform float uProgress;
        uniform float uSize;
        attribute float aRandom;
        varying float vAlpha;
        
        void main() {
          vec3 pos = position;
          
          // Orbital motion
          float angle = uTime * 0.1 * aRandom;
          float cosA = cos(angle);
          float sinA = sin(angle);
          pos.xz = mat2(cosA, -sinA, sinA, cosA) * pos.xz;
          
          // Move inward as progress increases
          float dist = length(pos);
          float targetDist = mix(dist, 2.0, uProgress * aRandom);
          pos = normalize(pos) * targetDist;
          
          // Fade based on depth
          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          vAlpha = smoothstep(-10.0, 0.0, mvPosition.z) * (0.3 + aRandom * 0.7);
          
          gl_Position = projectionMatrix * mvPosition;
          gl_PointSize = uSize * (1.0 / -mvPosition.z) * (0.5 + aRandom * 0.5);
        }
      `,
      fragmentShader: `
        varying float vAlpha;
        
        void main() {
          float dist = length(gl_PointCoord - 0.5);
          if (dist > 0.5) discard;
          
          float alpha = smoothstep(0.5, 0.0, dist) * vAlpha;
          gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    
    const particles = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particles);
    
    // ============================================
    // ANIMATION STATE (Proxy Pattern)
    // ============================================
    const animationState = {
      progress: 0,
      targetProgress: 0,
      mouse: { x: 0, y: 0 },
      targetMouse: { x: 0, y: 0 }
    };
    
    // ============================================
    // SCROLL HANDLING
    // ============================================
    let scrollProgress = 0;
    const totalHeight = document.body.scrollHeight - window.innerHeight;
    
    window.addEventListener('scroll', () => {
      scrollProgress = window.scrollY / totalHeight;
      animationState.targetProgress = scrollProgress;
    }, { passive: true });
    
    // ============================================
    // MOUSE HANDLING
    // ============================================
    window.addEventListener('mousemove', (e) => {
      animationState.targetMouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      animationState.targetMouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });
    
    // ============================================
    // RESIZE HANDLING
    // ============================================
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        bloomPass.resolution.set(window.innerWidth, window.innerHeight);
      }, 100);
    });
    
    // ============================================
    // CONTEXT LOSS HANDLING
    // ============================================
    canvas.addEventListener('webglcontextlost', (e) => {
      e.preventDefault();
      cancelAnimationFrame(animationId);
    });
    
    canvas.addEventListener('webglcontextrestored', () => {
      init();
      animate();
    });
    
    // ============================================
    // CAMERA PATH INTERPOLATION
    // ============================================
    function updateCamera(progress) {
      const segments = CONFIG.cameraPath.length - 1;
      const segmentProgress = progress * segments;
      const segmentIndex = Math.min(Math.floor(segmentProgress), segments - 1);
      const localProgress = segmentProgress - segmentIndex;
      
      const eased = easeInOutCubic(localProgress);
      
      const from = CONFIG.cameraPath[segmentIndex];
      const to = CONFIG.cameraPath[segmentIndex + 1] || from;
      
      camera.position.x = lerp(from.pos[0], to.pos[0], eased);
      camera.position.y = lerp(from.pos[1], to.pos[1], eased);
      camera.position.z = lerp(from.pos[2], to.pos[2], eased);
      
      const targetX = lerp(from.target[0], to.target[0], eased);
      const targetY = lerp(from.target[1], to.target[1], eased);
      const targetZ = lerp(from.target[2], to.target[2], eased);
      camera.lookAt(targetX, targetY, targetZ);
    }
    
    function lerp(a, b, t) {
      return a + (b - a) * t;
    }
    
    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }
    
    // ============================================
    // ANIMATION LOOP
    // ============================================
    const clock = new THREE.Clock();
    let animationId;
    let isVisible = true;
    
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        isVisible = false;
        clock.stop();
      } else {
        isVisible = true;
        clock.start();
        clock.getDelta(); // Reset delta
      }
    });
    
    function animate() {
      animationId = requestAnimationFrame(animate);
      
      if (!isVisible) return;
      
      const delta = Math.min(clock.getDelta(), 0.1);
      const elapsed = clock.getElapsedTime();
      
      // Smooth interpolation (lerping)
      animationState.progress += (animationState.targetProgress - animationState.progress) * 0.05;
      animationState.mouse.x += (animationState.targetMouse.x - animationState.mouse.x) * 0.05;
      animationState.mouse.y += (animationState.targetMouse.y - animationState.mouse.y) * 0.05;
      
      // Update uniforms
      const time = prefersReducedMotion ? 0 : elapsed;
      heroMaterial.uniforms.uTime.value = time;
      heroMaterial.uniforms.uProgress.value = animationState.progress;
      heroMaterial.uniforms.uMouse.value.set(animationState.mouse.x, animationState.mouse.y);
      
      particlesMaterial.uniforms.uTime.value = time;
      particlesMaterial.uniforms.uProgress.value = animationState.progress;
      
      postPass.uniforms.uTime.value = time;
      
      // Update hero rotation
      if (!prefersReducedMotion) {
        heroMesh.rotation.y = elapsed * 0.1 + animationState.mouse.x * 0.3;
        heroMesh.rotation.x = Math.sin(elapsed * 0.2) * 0.1 + animationState.mouse.y * 0.2;
      }
      
      // Update camera based on scroll
      updateCamera(animationState.progress);
      
      // Render
      composer.render();
    }
    
    // ============================================
    // INTRO ANIMATION
    // ============================================
    function playIntro() {
      // Hide loader
      gsap.to('.loader', {
        opacity: 0,
        duration: 0.5,
        onComplete: () => {
          document.querySelector('.loader').style.display = 'none';
        }
      });
      
      // Animate hero text
      gsap.to('.hero h1', {
        opacity: 1,
        y: 0,
        duration: 1.2,
        ease: 'power3.out',
        delay: 0.3
      });
      
      gsap.to('.hero p', {
        opacity: 1,
        y: 0,
        duration: 1,
        ease: 'power3.out',
        delay: 0.6
      });
      
      // Show scroll indicator
      gsap.to('.scroll-indicator', {
        opacity: 1,
        duration: 0.5,
        delay: 1.5
      });
    }
    
    // ============================================
    // LOADING
    // ============================================
    function updateLoader(progress) {
      document.querySelector('.loader-progress').style.width = `${progress * 100}%`;
    }
    
    function init() {
      // Simulate loading (in real app, use LoadingManager)
      let progress = 0;
      const interval = setInterval(() => {
        progress += 0.1;
        updateLoader(Math.min(progress, 1));
        
        if (progress >= 1) {
          clearInterval(interval);
          setTimeout(playIntro, 300);
        }
      }, 100);
    }
    
    // ============================================
    // START
    // ============================================
    init();
    animate();
  </script>
</body>
</html>
